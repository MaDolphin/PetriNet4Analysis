% TeX root = ../../paper.tex

\section{Language}\label{sec:language}

The \emph{petrinets4analysis} language is defined on a syntactical level (in particular, the parser) and on a semantic level, both aided by MontiCore generation capabilities. In this section, we discuss implementation choices for both of these.

\subsection{Grammar Design}

The syntactic foundation of a textual software language is a context-free grammar which defines all valid keywords and permissible input values as well as syntactic sugar (e.g. punctuation and bracketing), and their static arrangement~\cite{rumpe2017monticore}. We define a grammar for the MontiCore Language Workbench that specifies the syntax of the \emph{petrinets4analysis} language, which produces Java classes for the abstract syntax tree (AST) as well as additional infrastructure (cf. Section~\ref{sec:implementation}). The desired modeling elements are

\begin{itemize}
    \item structural features: places, transitions and edges between them
    \item behavioral annotations: initial markings, i.e. token counts in places, and weights on edges
    \item presupposition of analytical conditions that ensure conformance with certain behavioral properties (e.g. boundedness, cf. Section \ref{sec:background:properties})
\end{itemize}

Consequently, the \texttt{Petrinet} grammar in Listing \ref{lst:language:grammar} defines the structure of the \emph{petrinets4analysis} language. It contains non-terminals for the most important elements to represent the required modeling capabilities. Places (l.~\ref{grammar:place}), transitions (l.~\ref{grammar:transition}) and edges (l.~\ref{grammar:edgestart}-\ref{grammar:edgeend}) are represented by the non-terminals of the corresponding name.

\begin{lstfloat}
	\centering
\begin{lstlisting}[style=mcgrammar]
grammar Petrinet extends de.monticore.literals.Literals {
	
	scope Petrinet = "petrinet" Name "{"
		Assertion*
		(Place | Transition)*
	"}";
	
	Assertion = "assert" Requirement ";";
	
	interface Requirement;/@\label{grammar:requirement}@/
	astrule Requirement =
	method Optional<Boolean> verify(ASTPetrinet petrinet) { };
	
	GlobalRequirement implements Requirement = GlobalFeature;/@\label{grammar:globalreq}@/
	enum GlobalFeature = "bounded" | "safe";
	SubclassRequirement implements Requirement = Subclass;
	enum Subclass = "state_machine" | "marked_graph" | "free_choice"
		| "extended_free_choice" | "asymmetric_choice";
	
	Liveness implements Requirement =
		LivenessLevel ("(" ("*" | (TransitionReference || ",")+) ")")?;
	enum LivenessLevel = "l0live" | "l1live";
	TransitionReference = transition:Name@Transition;/@\label{grammar:liveend}@/
	
	symbol Place = "place" Name ("initial" initial:IntLiteral)? ";";/@\label{grammar:place}@/
	astrule Place = outEdge:FromEdge* inEdge:ToEdge*;/@\label{grammar:placeast}@/
	
	symbol Transition = "transition" Name ":" (FromEdge | ToEdge)*;/@\label{grammar:transition}@/
	
	abstract Edge = count:IntLiteral place:Name@Place;/@\label{grammar:edgestart}@/
	FromEdge extends Edge = count:IntLiteral "<-" place:Name@Place;
	ToEdge extends Edge = count:IntLiteral "->" place:Name@Place;/@\label{grammar:edgeend}@/
}
\end{lstlisting}
	\caption{The \emph{petrinets4analysis} MontiCore grammar}\label{lst:language:grammar}
\end{lstfloat}

Analytical preconditions can be imposed by the \texttt{Assertion} non-terminal, which itself contains a \texttt{Requirement} interface (l.~\ref{grammar:requirement}). As in object-oriented programming languages, interface non-terminals in MontiCore grammars have to be implemented by concrete types that expose certain methods. Here, implementing non-terminals correspond to criteria expected of the model, and they must implement a method for their verification. This interface pattern makes the language extensible to more criteria. Our \texttt{Liveness}, \texttt{GlobalFeature} (for boundedness or safeness) and \texttt{SubclassRequirement} (l.~\ref{grammar:globalreq}-\ref{grammar:liveend}) non-terminals implement this interface and can thus be used in models of the language.

Another design detail of the grammar is the segmentation of edges into \texttt{FromEdge} and \texttt{ToEdge}. It would be possible to formalize edges as one non-terminal, where the two different directions (defined by \texttt{<-} and \texttt{->}) are only differentiated by a Boolean attribute. However, for analysis purposes it is convenient to access these sets separately (including derived properties, such as their size). Modeling the grammar with a Boolean attribute that distinguishes the edges would mean to search through all existing edges and check the Boolean attribute each time the application accesses any kind of edge. Our approach ensures that incoming and outgoing edges are saved separately, leveraging the methods generated by MontiCore.

While \texttt{Transition} non-terminals contain edges naturally as part of the AST, places have no reference to them. However, analysis implementations must be able to access incoming and outgoing edges of a place; we add them manually---again utilizing MontiCore to define these lists' interfaces through an \texttt{astrule} for the \texttt{Place} non-terminal.

\subsection{Well-formedness of Models}\label{sec:lang:semantics}

The grammar ensures syntactic correctness of textual petri net definitions, but additionally, models must be well-formed. This can be verified via context conditions (cocos) in MontiCore. Cocos are handwritten Java classes implementing a specific visitor pattern that check the internal representation of defined models for contextual inconsistencies~\cite{rumpe2017monticore}. For the petri net language, we define the following rules:

\begin{itemize}
    \item Place and transition names must be unique.
    \item Edges in one transition must be unique.
    \item Assertions must appear uniquely.
    \item Place and transition names must exist if they are referred to in the model.
    \item A model has to satisfy all assertions stated in the model definition.
\end{itemize}

With the first four conditions the correct parsing and interpretation of the models is guaranteed, since there is no possibility for ambiguities or usage of non-existing objects. Furthermore, the last coco delivers a mechanism to reject petri nets which claim conformance with properties (e.g. boundedness, liveness) but do not satisfy them: with this mechanism, continuous verification within the modeling process is made possible.
